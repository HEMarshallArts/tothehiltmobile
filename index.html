<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To The Hilt - A Tournament of Confusion and Disorder</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cinzel+Decorative:wght@700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, #2c1810 0%, #4a3728 100%);
            color: #f4e4c1;
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: rgba(20, 15, 10, 0.9);
            border-radius: 15px;
            border: 2px solid #8b7355;
            box-shadow: 0 0 20px rgba(139, 115, 85, 0.3);
            padding: 15px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #8b7355;
        }

        .title {
            font-family: 'Cinzel Decorative', serif;
            font-size: 1.8em;
            color: #d4af37;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 0.9em;
            color: #c9a96e;
            font-style: italic;
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        .input-section {
            text-align: center;
            margin-bottom: 20px;
        }

        .input-section h2 {
            color: #d4af37;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        textarea {
            width: 100%;
            height: 150px;
            background: rgba(244, 228, 193, 0.1);
            border: 2px solid #8b7355;
            border-radius: 10px;
            color: #f4e4c1;
            font-family: 'Cinzel', serif;
            font-size: 14px;
            padding: 12px;
            resize: vertical;
        }

        textarea::placeholder {
            color: #c9a96e;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .setting-group {
            text-align: center;
        }

        .setting-group label {
            color: #d4af37;
            font-size: 1em;
            display: block;
            margin-bottom: 5px;
        }

        .setting-group input {
            padding: 10px;
            font-size: 16px;
            font-family: 'Cinzel', serif;
            background: rgba(244, 228, 193, 0.1);
            border: 2px solid #8b7355;
            border-radius: 5px;
            color: #f4e4c1;
            width: 100%;
            max-width: 120px;
        }

        .btn {
            background: linear-gradient(135deg, #8b7355 0%, #6b5a47 100%);
            color: #f4e4c1;
            border: 2px solid #d4af37;
            padding: 15px 20px;
            border-radius: 8px;
            font-family: 'Cinzel', serif;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            margin: 10px 5px;
            width: 100%;
            max-width: 300px;
        }

        .btn:hover {
            background: linear-gradient(135deg, #a08660 0%, #8b7355 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(212, 175, 55, 0.3);
        }

        .matches-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: rgba(244, 228, 193, 0.05);
            border-radius: 10px;
            overflow: hidden;
            font-size: 12px;
        }

        .matches-table th,
        .matches-table td {
            padding: 8px 4px;
            text-align: center;
            border-bottom: 1px solid rgba(139, 115, 85, 0.3);
            word-wrap: break-word;
        }

        .matches-table th {
            background: rgba(212, 175, 55, 0.2);
            color: #d4af37;
            font-weight: 700;
            font-size: 11px;
        }

        .match-row {
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .match-row:hover {
            background: rgba(139, 115, 85, 0.2);
        }

        .match-row.completed {
            background: rgba(76, 175, 80, 0.2);
        }

        .match-row.current {
            background: rgba(212, 175, 55, 0.3);
            font-weight: bold;
            border: 2px solid #d4af37;
        }

        .match-row.current:hover {
            background: rgba(212, 175, 55, 0.4);
        }

        .fighting-arena {
            display: flex;
            flex-direction: row !important;
            gap: 10px;
            margin: 20px 0;
            height: 60vh;
        }

        .fighter {
            flex: 1;
            text-align: center;
            background: rgba(244, 228, 193, 0.1);
            border-radius: 15px;
            padding: 15px 10px;
            border: 3px solid transparent;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .fighter.red {
            border-color: #dc3545;
        }

        .fighter.blue {
            border-color: #007bff;
        }

        .fighter-name {
            font-size: 1.2em;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .fighter.red .fighter-name {
            color: #dc3545;
        }

        .fighter.blue .fighter-name {
            color: #007bff;
        }

        .score {
            font-size: 3em;
            font-weight: 700;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            flex-grow: 0;
        }

        .score-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-grow: 1;
            justify-content: center;
        }

        .score-btn {
            padding: 20px 10px;
            font-size: 14px;
            border-radius: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
            text-align: center;
            line-height: 1.3;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .score-btn.hilt {
            background: linear-gradient(135deg, #d4af37 0%, #b8941f 100%);
            color: #2c1810;
        }

        .score-btn.critical {
            background: linear-gradient(135deg, #ff6b35 0%, #e55125 100%);
            color: white;
        }

        .score-btn.scratch {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
            color: white;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        .match-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #d4af37;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: rgba(244, 228, 193, 0.05);
            border-radius: 10px;
            overflow: hidden;
            font-size: 11px;
        }

        .results-table th,
        .results-table td {
            padding: 8px 3px;
            text-align: center;
            border-bottom: 1px solid rgba(139, 115, 85, 0.3);
        }

        .results-table th {
            background: rgba(212, 175, 55, 0.2);
            color: #d4af37;
            font-weight: 700;
            font-size: 10px;
        }

        .winner {
            color: #28a745;
            font-weight: bold;
        }

        .loser {
            color: #dc3545;
        }

        .final-results {
            text-align: center;
        }

        .ranking {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin: 8px 0;
            background: rgba(244, 228, 193, 0.1);
            border-radius: 10px;
            border: 2px solid #8b7355;
        }

        .ranking.first {
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.2);
        }

        .ranking.second {
            border-color: #c0c0c0;
            background: rgba(192, 192, 192, 0.1);
        }

        .ranking.third {
            border-color: #cd7f32;
            background: rgba(205, 127, 50, 0.1);
        }

        .victory-screen {
            text-align: center;
            padding: 25px;
            background: rgba(76, 175, 80, 0.2);
            border-radius: 15px;
            border: 3px solid #4caf50;
            margin: 15px 0;
        }

        .victory-screen h2 {
            color: #4caf50;
            font-size: 2em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .final-score {
            font-size: 1.4em;
            margin: 15px 0;
            color: #f4e4c1;
        }

        .timer-section {
            text-align: center;
            margin: 15px 0;
            padding: 15px;
            background: rgba(244, 228, 193, 0.1);
            border-radius: 15px;
            border: 2px solid #8b7355;
        }

        .timer-display {
            font-size: 2.5em;
            font-weight: 700;
            color: #d4af37;
            margin-bottom: 12px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-family: 'Cinzel', serif;
        }

        .timer-display.warning {
            color: #ff6b35;
            animation: pulse 1s infinite;
        }

        .timer-display.expired {
            color: #dc3545;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .timer-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .timer-btn {
            padding: 8px 15px;
            font-size: 12px;
            flex: 1;
            min-width: 70px;
        }

        .button-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .button-row .btn {
            flex: 1;
            min-width: 120px;
            margin: 5px;
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .container {
                padding: 10px;
                border-radius: 10px;
            }

            .title {
                font-size: 1.5em;
            }

            .subtitle {
                font-size: 0.8em;
            }

            .matches-table,
            .results-table {
                font-size: 10px;
            }

            .matches-table th,
            .matches-table td,
            .results-table th,
            .results-table td {
                padding: 6px 2px;
            }

            .fighting-arena {
                flex-direction: row !important;
                height: 55vh;
                gap: 8px;
            }

            .fighter-name {
                font-size: 1em;
            }

            .score {
                font-size: 2.5em;
                margin: 8px 0;
            }

            .score-btn {
                padding: 15px 8px;
                font-size: 12px;
                min-height: 50px;
                gap: 3px;
            }

            .btn {
                padding: 12px 15px;
                font-size: 14px;
            }

            .timer-display {
                font-size: 2em;
            }
        }

        @media (max-width: 360px) {
            body {
                padding: 5px;
            }

            .container {
                padding: 8px;
            }

            .title {
                font-size: 1.3em;
            }

            .matches-table,
            .results-table {
                font-size: 9px;
            }

            .fighting-arena {
                flex-direction: row !important;
                height: 50vh;
                gap: 6px;
            }

            .score {
                font-size: 2.2em;
                margin: 6px 0;
            }

            .score-btn {
                padding: 12px 6px;
                font-size: 11px;
                min-height: 45px;
            }
        }

        /* Landscape orientation adjustments */
        @media (orientation: landscape) and (max-height: 500px) {
            .fighting-arena {
                flex-direction: row !important;
                height: 70vh;
            }

            .score {
                font-size: 2.2em;
                margin: 5px 0;
            }

            .timer-display {
                font-size: 1.8em;
            }

            .score-btn {
                padding: 12px 8px;
                font-size: 11px;
                min-height: 40px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">To The Hilt</h1>
            <p class="subtitle">A Tournament of Confusion and Disorder</p>
        </div>

        <!-- Fighter Input Screen -->
        <div id="input-screen" class="screen active">
            <div class="input-section">
                <h2>Enter Fighter Names</h2>
                <textarea id="fighter-input" placeholder="Enter fighter names, one per line..."></textarea>
                
                <div class="settings-grid">
                    <div class="setting-group">
                        <label for="pool-size">Pool Size:</label>
                        <input type="number" id="pool-size" min="3" max="10" value="5">
                    </div>
                    <div class="setting-group">
                        <label for="rounds-per-fighter">Rounds per Fighter:</label>
                        <input type="number" id="rounds-per-fighter" min="1" max="5" value="1">
                    </div>
                    <div class="setting-group">
                        <label for="match-duration">Match Duration (min, 0 = no timer):</label>
                        <input type="number" id="match-duration" min="0" max="30" value="0" step="0.5">
                    </div>
                </div>
                
                <button class="btn" onclick="generateTournament()">Generate Tournament</button>
                <button class="btn" onclick="quickStart()" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); border-color: #28a745;">Quick Start (3 Min Match)</button>
            </div>
        </div>

        <!-- Match List Screen -->
        <div id="matches-screen" class="screen">
            <h2 style="color: #d4af37; text-align: center; margin-bottom: 15px; font-size: 1.3em;">Tournament Matches</h2>
            <div class="button-row">
                <button class="btn" onclick="showScreen('input-screen')" style="max-width: 200px;">← Back to Setup</button>
            </div>
            <table class="matches-table" id="matches-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Red</th>
                        <th>Blue</th>
                        <th>Pool</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="matches-tbody">
                </tbody>
            </table>
        </div>

        <!-- Fighting Screen -->
        <div id="fighting-screen" class="screen">
            <div class="button-row">
                <button class="btn" onclick="showScreen('matches-screen')" style="max-width: 200px;">← Back to Matches</button>
            </div>
            
            <div class="match-info" id="match-info">
                Match 1 of 10
            </div>
            
            <!-- Timer Section -->
            <div id="timer-section" class="timer-section" style="display: none;">
                <div class="timer-display" id="timer-display">3:00</div>
                <div class="timer-controls">
                    <button class="btn timer-btn" id="start-btn" onclick="startTimer()">Start</button>
                    <button class="btn timer-btn" id="stop-btn" onclick="stopTimer()">Stop</button>
                    <button class="btn timer-btn" onclick="resetTimer()">Reset</button>
                </div>
            </div>
            
            <div class="fighting-arena">
                <div class="fighter red">
                    <div class="fighter-name" id="red-name">Fighter 1</div>
                    <div class="score" id="red-score">0</div>
                    <div class="score-buttons">
                        <button class="score-btn hilt" onclick="addScore('red', 3)">
                            <span>To the hilt</span>
                            <span>+3</span>
                        </button>
                        <button class="score-btn critical" onclick="addScore('red', 2)">
                            <span>Critical hit</span>
                            <span>+2</span>
                        </button>
                        <button class="score-btn scratch" onclick="addScore('red', 1)">
                            <span>Tis but a scratch</span>
                            <span>+1</span>
                        </button>
                    </div>
                </div>

                <div class="fighter blue">
                    <div class="fighter-name" id="blue-name">Fighter 2</div>
                    <div class="score" id="blue-score">0</div>
                    <div class="score-buttons">
                        <button class="score-btn hilt" onclick="addScore('blue', 3)">
                            <span>To the hilt</span>
                            <span>+3</span>
                        </button>
                        <button class="score-btn critical" onclick="addScore('blue', 2)">
                            <span>Critical hit</span>
                            <span>+2</span>
                        </button>
                        <button class="score-btn scratch" onclick="addScore('blue', 1)">
                            <span>Tis but a scratch</span>
                            <span>+1</span>
                        </button>
                    </div>
                </div>
            </div>

            <div class="controls">
                <button class="btn" onclick="undo()">Undo</button>
            </div>
        </div>

        <!-- Victory Screen -->
        <div id="victory-screen" class="screen">
            <div class="victory-screen">
                <h2>Victory!</h2>
                <div class="final-score" id="victory-text">Red Fighter wins 10-5!</div>
                <div id="tournament-next-controls">
                    <button class="btn" onclick="nextMatch()">Next Match</button>
                </div>
                <div id="quickstart-next-controls" style="display: none;">
                    <button class="btn" onclick="anotherQuickMatch()">Another Match?</button>
                    <button class="btn" onclick="goHome()">Home Screen</button>
                </div>
            </div>
        </div>

        <!-- Match Results Screen -->
        <div id="results-screen" class="screen">
            <h2 style="color: #d4af37; text-align: center; margin-bottom: 15px; font-size: 1.3em;">Match Results</h2>
            <div class="button-row">
                <button class="btn" onclick="showScreen('matches-screen')" style="max-width: 200px;">← Back to Matches</button>
            </div>
            <table class="results-table" id="results-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Red</th>
                        <th>Blue</th>
                        <th>Score</th>
                        <th>Winner</th>
                    </tr>
                </thead>
                <tbody id="results-tbody">
                </tbody>
            </table>
            <div class="button-row">
                <button class="btn" onclick="showFinalRankings()">View Final Rankings</button>
            </div>
        </div>

        <!-- Final Rankings Screen -->
        <div id="rankings-screen" class="screen">
            <div class="final-results">
                <h2 style="color: #d4af37; margin-bottom: 20px; font-size: 1.3em;">Final Tournament Rankings</h2>
                <div class="button-row">
                    <button class="btn" onclick="showScreen('results-screen')" style="max-width: 200px;">← Back to Results</button>
                </div>
                <div id="rankings-list"></div>
                <div class="button-row">
                    <button class="btn" onclick="exportToCSV()">Export CSV</button>
                    <button class="btn" onclick="restartTournament()">New Tournament</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let fighters = [];
        let matches = [];
        let currentMatchIndex = 0;
        let scoreHistory = [];
        let matchResults = [];
        let roundsPerFighter = 1;
        let matchDurationMinutes = 0;
        let timerSeconds = 0;
        let timerInterval = null;
        let timerRunning = false;
        let isQuickStartMode = false;

        function generateTournament() {
            const input = document.getElementById('fighter-input').value.trim();
            if (!input) {
                alert('Please enter fighter names!');
                return;
            }

            fighters = input.split('\n').filter(name => name.trim()).map(name => name.trim());
            
            if (fighters.length < 2) {
                alert('Please enter at least 2 fighters!');
                return;
            }

            // Get tournament settings
            roundsPerFighter = parseInt(document.getElementById('rounds-per-fighter').value) || 1;
            matchDurationMinutes = parseFloat(document.getElementById('match-duration').value) || 0;

            matches = generateMatches(fighters);
            isQuickStartMode = false;
            displayMatches();
            showScreen('matches-screen');
        }

        function quickStart() {
            // Set up a quick 3-minute match between Red and Blue
            isQuickStartMode = true;
            matchDurationMinutes = 3;
            
            // Create a single quick match
            const quickMatch = {
                redFighter: 'Red',
                blueFighter: 'Blue',
                completed: false,
                redScore: 0,
                blueScore: 0,
                winner: null,
                id: 1
            };
            
            matches = [quickMatch];
            currentMatchIndex = 0;
            
            // Set up the fighting screen
            document.getElementById('red-name').textContent = 'Red';
            document.getElementById('blue-name').textContent = 'Blue';
            document.getElementById('red-score').textContent = '0';
            document.getElementById('blue-score').textContent = '0';
            document.getElementById('match-info').textContent = 'Quick Match';
            
            // Setup timer
            const timerSection = document.getElementById('timer-section');
            timerSection.style.display = 'block';
            initializeTimer();
            
            scoreHistory = [];
            showScreen('fighting-screen');
        }

        function generateMatches(fighterList) {
            // Get user-specified pool size
            const desiredPoolSize = parseInt(document.getElementById('pool-size').value) || 5;
            const totalFighters = fighterList.length;
            
            // Calculate actual pools to distribute fighters equally
            const numPools = Math.ceil(totalFighters / desiredPoolSize);
            const actualPoolSize = Math.ceil(totalFighters / numPools);
            
            // Create pools with random distribution
            const pools = [];
            const shuffledFighters = [...fighterList].sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < numPools; i++) {
                const startIndex = i * actualPoolSize;
                const endIndex = Math.min(startIndex + actualPoolSize, shuffledFighters.length);
                if (startIndex < shuffledFighters.length) {
                    pools.push(shuffledFighters.slice(startIndex, endIndex));
                }
            }

            // Generate all potential matches for each pool (including multiple rounds)
            const allMatches = [];
            pools.forEach((pool, poolIndex) => {
                for (let round = 1; round <= roundsPerFighter; round++) {
                    for (let i = 0; i < pool.length; i++) {
                        for (let j = i + 1; j < pool.length; j++) {
                            allMatches.push({
                                redFighter: pool[i],
                                blueFighter: pool[j],
                                pool: poolIndex + 1,
                                round: round,
                                completed: false,
                                redScore: 0,
                                blueScore: 0,
                                winner: null
                            });
                        }
                    }
                }
            });

            // Optimize match order to maximize rest time between fights
            const orderedMatches = optimizeMatchOrder(allMatches);
            
            // Add match IDs after ordering
            orderedMatches.forEach((match, index) => {
                match.id = index + 1;
            });

            return orderedMatches;
        }

        function optimizeMatchOrder(matches) {
            const orderedMatches = [];
            const remainingMatches = [...matches];
            const fighterLastMatch = {}; // Track when each fighter last fought
            
            while (remainingMatches.length > 0) {
                let bestMatchIndex = -1;
                let bestScore = -Infinity;
                
                // Find the match that gives fighters the most rest time
                for (let i = 0; i < remainingMatches.length; i++) {
                    const match = remainingMatches[i];
                    const redLastMatch = fighterLastMatch[match.redFighter];
                    const blueLastMatch = fighterLastMatch[match.blueFighter];
                    
                    // Calculate rest time for both fighters (matches since last fight)
                    const currentMatchNumber = orderedMatches.length;
                    const redRest = redLastMatch !== undefined ? (currentMatchNumber - redLastMatch) : 1000; // High value for first fight
                    const blueRest = blueLastMatch !== undefined ? (currentMatchNumber - blueLastMatch) : 1000;
                    
                    // Calculate score based on rest time
                    // Prioritize minimum rest (avoid consecutive fights) with bonus for total rest
                    const minRest = Math.min(redRest, blueRest);
                    const totalRest = redRest + blueRest;
                    
                    // Heavy penalty for consecutive fights (rest = 1), strong preference for longer rest
                    let score;
                    if (minRest <= 1) {
                        score = -1000 + totalRest; // Severe penalty for consecutive fights
                    } else {
                        score = minRest * 100 + totalRest; // Reward longer minimum rest
                    }
                    
                    // Additional bonus for balanced rest (both fighters rested similarly)
                    const restBalance = 10 - Math.abs(redRest - blueRest);
                    score += restBalance;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatchIndex = i;
                    }
                }
                
                // If no good matches found (all would be consecutive), pick the least bad
                if (bestMatchIndex === -1) {
                    bestMatchIndex = 0;
                }
                
                // Add the best match to the ordered list
                const selectedMatch = remainingMatches.splice(bestMatchIndex, 1)[0];
                orderedMatches.push(selectedMatch);
                
                // Update when these fighters last fought
                fighterLastMatch[selectedMatch.redFighter] = orderedMatches.length - 1;
                fighterLastMatch[selectedMatch.blueFighter] = orderedMatches.length - 1;
            }
            
            return orderedMatches;
        }

        function displayMatches() {
            const tbody = document.getElementById('matches-tbody');
            tbody.innerHTML = '';

            // Find the next match that should be fought (first uncompleted match)
            let nextMatchIndex = -1;
            for (let i = 0; i < matches.length; i++) {
                if (!matches[i].completed) {
                    nextMatchIndex = i;
                    break;
                }
            }

            matches.forEach((match, index) => {
                const row = document.createElement('tr');
                
                // Only allow clicking on the next sequential match
                const isNextMatch = index === nextMatchIndex;
                const isCompleted = match.completed;
                const isCurrent = index === currentMatchIndex;
                
                if (isNextMatch && !isCompleted) {
                    row.className = `match-row current`;
                    row.onclick = () => startMatch(index);
                    row.style.cursor = 'pointer';
                } else if (isCompleted) {
                    row.className = `match-row completed`;
                    row.style.cursor = 'default';
                } else {
                    row.className = `match-row`;
                    row.style.cursor = 'not-allowed';
                    row.style.opacity = '0.6';
                }

                // Truncate names for mobile display
                const redName = match.redFighter.length > 8 ? match.redFighter.substring(0, 8) + '...' : match.redFighter;
                const blueName = match.blueFighter.length > 8 ? match.blueFighter.substring(0, 8) + '...' : match.blueFighter;
                
                let status;
                if (match.completed) {
                    status = `${match.winner.substring(0, 6)}${match.winner.length > 6 ? '...' : ''} wins`;
                } else if (isNextMatch) {
                    status = 'NEXT';
                } else {
                    status = 'Waiting';
                }

                row.innerHTML = `
                    <td>${match.id}</td>
                    <td title="${match.redFighter}">${redName}</td>
                    <td title="${match.blueFighter}">${blueName}</td>
                    <td>P${match.pool}${roundsPerFighter > 1 ? `R${match.round}` : ''}</td>
                    <td title="${match.completed ? `${match.winner} wins ${match.redScore}-${match.blueScore}` : status}">${status}</td>
                `;

                tbody.appendChild(row);
            });
        }

        function startMatch(matchIndex) {
            // Only allow starting the next sequential match
            let nextMatchIndex = -1;
            for (let i = 0; i < matches.length; i++) {
                if (!matches[i].completed) {
                    nextMatchIndex = i;
                    break;
                }
            }
            
            // Prevent starting any match that isn't the next in sequence
            if (matchIndex !== nextMatchIndex) {
                alert('Matches must be completed in sequential order. Please complete the highlighted match next.');
                return;
            }
            
            if (matches[matchIndex].completed) return;
            
            currentMatchIndex = matchIndex;
            const match = matches[currentMatchIndex];
            
            document.getElementById('red-name').textContent = match.redFighter;
            document.getElementById('blue-name').textContent = match.blueFighter;
            document.getElementById('red-score').textContent = match.redScore;
            document.getElementById('blue-score').textContent = match.blueScore;
            document.getElementById('match-info').textContent = `Match ${match.id} of ${matches.length}${roundsPerFighter > 1 ? ` (Round ${match.round})` : ''}`;
            
            // Setup timer if duration is specified
            const timerSection = document.getElementById('timer-section');
            if (matchDurationMinutes > 0) {
                timerSection.style.display = 'block';
                initializeTimer();
            } else {
                timerSection.style.display = 'none';
            }
            
            scoreHistory = [];
            showScreen('fighting-screen');
        }

        function initializeTimer() {
            timerSeconds = Math.floor(matchDurationMinutes * 60);
            updateTimerDisplay();
            stopTimer(); // Ensure timer is stopped
            
            // Remove any existing end match button when initializing
            const timerSection = document.getElementById('timer-section');
            const existingBtn = timerSection.querySelector('.end-match-btn');
            if (existingBtn) {
                existingBtn.remove();
            }
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timerSeconds / 60);
            const seconds = timerSeconds % 60;
            const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            const timerDisplay = document.getElementById('timer-display');
            timerDisplay.textContent = display;
            
            // Change color based on remaining time
            timerDisplay.classList.remove('warning', 'expired');
            if (timerSeconds <= 0) {
                timerDisplay.classList.add('expired');
            } else if (timerSeconds <= 15) {
                timerDisplay.classList.add('warning');
            }
        }

        function startTimer() {
            if (timerRunning) return;
            
            timerRunning = true;
            document.getElementById('start-btn').disabled = true;
            document.getElementById('stop-btn').disabled = false;
            
            timerInterval = setInterval(() => {
                timerSeconds--;
                updateTimerDisplay();
                
                if (timerSeconds <= 0) {
                    timeExpired();
                }
            }, 1000);
        }

        function stopTimer() {
            if (!timerRunning) return;
            
            timerRunning = false;
            document.getElementById('start-btn').disabled = false;
            document.getElementById('stop-btn').disabled = true;
            
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function resetTimer() {
            stopTimer();
            initializeTimer();
            
            // Also remove end match button when resetting
            const timerSection = document.getElementById('timer-section');
            const existingBtn = timerSection.querySelector('.end-match-btn');
            if (existingBtn) {
                existingBtn.remove();
            }
        }

        function timeExpired() {
            stopTimer();
            
            // Show the end match button instead of automatically ending
            const endMatchBtn = document.createElement('button');
            endMatchBtn.className = 'btn';
            endMatchBtn.textContent = 'End Match';
            endMatchBtn.onclick = () => endTimedMatch();
            endMatchBtn.style.backgroundColor = '#dc3545';
            endMatchBtn.style.borderColor = '#dc3545';
            endMatchBtn.style.marginTop = '10px';
            
            const timerSection = document.getElementById('timer-section');
            
            // Remove any existing end match button
            const existingBtn = timerSection.querySelector('.end-match-btn');
            if (existingBtn) {
                existingBtn.remove();
            }
            
            endMatchBtn.classList.add('end-match-btn');
            timerSection.appendChild(endMatchBtn);
        }

        function endTimedMatch() {
            const match = matches[currentMatchIndex];
            const redScore = match.redScore;
            const blueScore = match.blueScore;
            
            // Determine winner by highest score, or declare draw
            if (redScore !== blueScore) {
                match.completed = true;
                match.winner = redScore > blueScore ? match.redFighter : match.blueFighter;
                
                const winnerName = match.winner;
                const finalScore = `${redScore}-${blueScore}`;
                
                document.getElementById('victory-text').textContent = `Time expired! ${winnerName} wins ${finalScore}!`;
            } else {
                // Handle tie - for now, we'll call it a draw and mark as completed
                match.completed = true;
                match.winner = 'Draw';
                
                document.getElementById('victory-text').textContent = `Time expired! Match ends in a draw ${redScore}-${blueScore}!`;
            }
            
            // Show appropriate controls based on mode
            if (isQuickStartMode) {
                document.getElementById('tournament-next-controls').style.display = 'none';
                document.getElementById('quickstart-next-controls').style.display = 'block';
            } else {
                document.getElementById('tournament-next-controls').style.display = 'block';
                document.getElementById('quickstart-next-controls').style.display = 'none';
            }
            
            showScreen('victory-screen');
            
            // Remove the end match button after use
            const timerSection = document.getElementById('timer-section');
            const existingBtn = timerSection.querySelector('.end-match-btn');
            if (existingBtn) {
                existingBtn.remove();
            }
        }

        function addScore(fighter, points) {
            const match = matches[currentMatchIndex];
            
            scoreHistory.push({
                fighter: fighter,
                points: points,
                redScore: match.redScore,
                blueScore: match.blueScore
            });

            if (fighter === 'red') {
                match.redScore += points;
            } else {
                match.blueScore += points;
            }

            updateScoreDisplay();
            checkForWin();
        }

        function updateScoreDisplay() {
            const match = matches[currentMatchIndex];
            document.getElementById('red-score').textContent = match.redScore;
            document.getElementById('blue-score').textContent = match.blueScore;
        }

        function checkForWin() {
            const match = matches[currentMatchIndex];
            const redScore = match.redScore;
            const blueScore = match.blueScore;

            if ((redScore >= 10 && redScore - blueScore >= 3) || 
                (blueScore >= 10 && blueScore - redScore >= 3)) {
                
                // Show alert asking if they want to end the fight
                const endFight = confirm("Point cap reached! End fight?");
                
                if (endFight) {
                    match.completed = true;
                    match.winner = redScore > blueScore ? match.redFighter : match.blueFighter;
                    
                    const winnerName = match.winner;
                    const finalScore = `${redScore}-${blueScore}`;
                    
                    document.getElementById('victory-text').textContent = `${winnerName} wins ${finalScore}!`;
                    
                    // Show appropriate controls based on mode
                    if (isQuickStartMode) {
                        document.getElementById('tournament-next-controls').style.display = 'none';
                        document.getElementById('quickstart-next-controls').style.display = 'block';
                    } else {
                        document.getElementById('tournament-next-controls').style.display = 'block';
                        document.getElementById('quickstart-next-controls').style.display = 'none';
                    }
                    
                    showScreen('victory-screen');
                }
                // If they choose not to end the fight, continue playing
            }
        }

        function undo() {
            if (scoreHistory.length === 0) return;
            
            const lastAction = scoreHistory.pop();
            const match = matches[currentMatchIndex];
            
            match.redScore = lastAction.redScore;
            match.blueScore = lastAction.blueScore;
            
            updateScoreDisplay();
        }

        function nextMatch() {
            if (isQuickStartMode) {
                // For quick start, just go back to home
                goHome();
                return;
            }
            
            // Find next uncompleted match
            let nextIndex = -1;
            for (let i = 0; i < matches.length; i++) {
                if (!matches[i].completed) {
                    nextIndex = i;
                    break;
                }
            }

            if (nextIndex !== -1) {
                displayMatches();
                showScreen('matches-screen');
            } else {
                // All matches complete
                showMatchResults();
            }
        }

        function anotherQuickMatch() {
            quickStart();
        }

        function goHome() {
            isQuickStartMode = false;
            stopTimer();
            showScreen('input-screen');
        }

        function showMatchResults() {
            const tbody = document.getElementById('results-tbody');
            tbody.innerHTML = '';

            matches.forEach(match => {
                if (match.completed) {
                    const row = document.createElement('tr');
                    
                    // Truncate names for mobile display
                    const redName = match.redFighter.length > 8 ? match.redFighter.substring(0, 8) + '...' : match.redFighter;
                    const blueName = match.blueFighter.length > 8 ? match.blueFighter.substring(0, 8) + '...' : match.blueFighter;
                    const winnerName = match.winner.length > 8 ? match.winner.substring(0, 8) + '...' : match.winner;
                    
                    row.innerHTML = `
                        <td>${match.id}</td>
                        <td class="${match.winner === match.redFighter ? 'winner' : 'loser'}" title="${match.redFighter}">${redName}</td>
                        <td class="${match.winner === match.blueFighter ? 'winner' : 'loser'}" title="${match.blueFighter}">${blueName}</td>
                        <td>${match.redScore}-${match.blueScore}</td>
                        <td class="winner" title="${match.winner}">${winnerName}</td>
                    `;
                    tbody.appendChild(row);
                }
            });

            showScreen('results-screen');
        }

        function showFinalRankings() {
            const fighterStats = {};
            
            // Initialize fighter stats
            fighters.forEach(fighter => {
                fighterStats[fighter] = { 
                    wins: 0, 
                    matches: 0, 
                    pointsFor: 0, 
                    pointsAgainst: 0 
                };
            });

            // Count wins and calculate point differences for each fighter
            matches.forEach(match => {
                if (match.completed && match.winner !== 'Draw') {
                    fighterStats[match.redFighter].matches++;
                    fighterStats[match.blueFighter].matches++;
                    
                    // Add points scored
                    fighterStats[match.redFighter].pointsFor += match.redScore;
                    fighterStats[match.redFighter].pointsAgainst += match.blueScore;
                    fighterStats[match.blueFighter].pointsFor += match.blueScore;
                    fighterStats[match.blueFighter].pointsAgainst += match.redScore;
                    
                    // Count wins
                    if (match.winner) {
                        fighterStats[match.winner].wins++;
                    }
                }
            });

            // Sort by wins first, then by point difference
            const sortedFighters = Object.entries(fighterStats)
                .sort((a, b) => {
                    const [nameA, statsA] = a;
                    const [nameB, statsB] = b;
                    
                    // Primary sort: by win percentage
                    const winRateA = statsA.matches > 0 ? statsA.wins / statsA.matches : 0;
                    const winRateB = statsB.matches > 0 ? statsB.wins / statsB.matches : 0;
                    
                    if (winRateA !== winRateB) {
                        return winRateB - winRateA; // Higher win rate first
                    }
                    
                    // Secondary sort: by point difference (points for - points against)
                    const pointDiffA = statsA.pointsFor - statsA.pointsAgainst;
                    const pointDiffB = statsB.pointsFor - statsB.pointsAgainst;
                    
                    if (pointDiffA !== pointDiffB) {
                        return pointDiffB - pointDiffA; // Higher point difference first
                    }
                    
                    // Tertiary sort: by total points scored
                    return statsB.pointsFor - statsA.pointsFor;
                });

            // Display rankings
            const rankingsList = document.getElementById('rankings-list');
            rankingsList.innerHTML = '';

            sortedFighters.forEach((entry, index) => {
                const [name, stats] = entry;
                const ranking = document.createElement('div');
                let rankingClass = '';
                
                if (index === 0) rankingClass = 'first';
                else if (index === 1) rankingClass = 'second';
                else if (index === 2) rankingClass = 'third';
                
                const pointDiff = stats.pointsFor - stats.pointsAgainst;
                const pointDiffText = pointDiff >= 0 ? `+${pointDiff}` : `${pointDiff}`;
                
                ranking.className = `ranking ${rankingClass}`;
                ranking.innerHTML = `
                    <span style="font-size: 1.1em; font-weight: bold;">${index + 1}. ${name}</span>
                    <span>${stats.wins}/${stats.matches} (${pointDiffText})</span>
                `;
                
                rankingsList.appendChild(ranking);
            });

            showScreen('rankings-screen');
        }

        function exportToCSV() {
            // Create CSV content with tournament results
            let csvContent = "Tournament Results - To The Hilt\n\n";
            
            // Tournament Summary
            csvContent += "FINAL RANKINGS\n";
            csvContent += "Rank,Fighter Name,Wins,Total Matches,Win Rate\n";
            
            // Calculate fighter stats
            const fighterStats = {};
            fighters.forEach(fighter => {
                fighterStats[fighter] = { wins: 0, matches: 0 };
            });

            matches.forEach(match => {
                if (match.completed) {
                    fighterStats[match.redFighter].matches++;
                    fighterStats[match.blueFighter].matches++;
                    
                    if (match.winner) {
                        fighterStats[match.winner].wins++;
                    }
                }
            });

            // Sort by wins and add to CSV
            const sortedFighters = Object.entries(fighterStats)
                .sort((a, b) => b[1].wins - a[1].wins);

            sortedFighters.forEach((entry, index) => {
                const [name, stats] = entry;
                const winRate = stats.matches > 0 ? ((stats.wins / stats.matches) * 100).toFixed(1) : "0.0";
                csvContent += `${index + 1},"${name}",${stats.wins},${stats.matches},${winRate}%\n`;
            });

            // Add detailed match results
            csvContent += "\n\nDETAILED MATCH RESULTS\n";
            csvContent += "Match,Pool,Round,Red Fighter,Red Score,Blue Fighter,Blue Score,Winner\n";

            matches.forEach(match => {
                if (match.completed) {
                    const round = match.round || 1;
                    csvContent += `${match.id},${match.pool},${round},"${match.redFighter}",${match.redScore},"${match.blueFighter}",${match.blueScore},"${match.winner}"\n`;
                }
            });

            // Create and download the file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            
            // Create filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString().slice(0, 19).replace(/[:-]/g, '').replace('T', '_');
            link.setAttribute('download', `ToTheHilt_Results_${timestamp}.csv`);
            
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function restartTournament() {
            fighters = [];
            matches = [];
            currentMatchIndex = 0;
            scoreHistory = [];
            matchResults = [];
            roundsPerFighter = 1;
            matchDurationMinutes = 0;
            isQuickStartMode = false;
            stopTimer(); // Stop any running timer
            
            document.getElementById('fighter-input').value = '';
            document.getElementById('pool-size').value = '5';
            document.getElementById('rounds-per-fighter').value = '1';
            document.getElementById('match-duration').value = '0';
            showScreen('input-screen');
        }

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }
    </script>
</body>
</html>
